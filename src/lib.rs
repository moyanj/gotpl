// temp_file_1a47289f-bd97-4e1a-85d9-b0e20e0b8d73_pasted_text.rs

use serde::Serialize;
use std::error::Error;
use std::ffi::{CStr, CString, NulError};
use std::fmt::{self, Display, Formatter};
use std::marker::PhantomData;

#[cfg(not(docsrs))]
mod goffi {
    #![allow(non_snake_case)]
    #![allow(non_camel_case_types)]
    #![allow(non_upper_case_globals)]
    #![allow(unused)]
    // include rust bindings generated by bindgen
    include!(concat!(env!("OUT_DIR"), "/api_bindings.rs"));
}

#[cfg(docsrs)]
mod goffi {
    #[repr(C)]
    pub struct RenderResult {
        pub output: *mut i8,
        pub error: *mut i8,
    }

    extern "C" {
        pub fn RenderTemplate(
            template_content: *mut i8,
            json_data: *mut i8,
            escape_html: bool,
            use_missing_key_zero: bool,
        ) -> RenderResult;
        pub fn FreeResultString(s: *mut i8);
    }
}

#[derive(Debug)]
pub enum RenderError {
    InvalidCString(NulError),
    JsonSerialization(serde_json::Error),
    GoExecution(String),
}

impl Display for RenderError {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            RenderError::InvalidCString(e) => {
                write!(f, "Failed to convert string to C-compatible string: {}", e)
            }
            RenderError::JsonSerialization(e) => {
                write!(f, "Failed to serialize data to JSON: {}", e)
            }
            RenderError::GoExecution(e) => write!(f, "Go template execution error: {}", e),
        }
    }
}

impl Error for RenderError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        match self {
            RenderError::InvalidCString(e) => Some(e),
            RenderError::JsonSerialization(e) => Some(e),
            RenderError::GoExecution(_) => None,
        }
    }
}

impl From<NulError> for RenderError {
    fn from(err: NulError) -> Self {
        RenderError::InvalidCString(err)
    }
}

impl From<serde_json::Error> for RenderError {
    fn from(err: serde_json::Error) -> Self {
        RenderError::JsonSerialization(err)
    }
}

struct OwnedGoResult(goffi::RenderResult);

impl Drop for OwnedGoResult {
    fn drop(&mut self) {
        // unsafe 代码块被严格限制在 drop 实现中。
        // 这是确保内存安全的关键。
        unsafe {
            goffi::FreeResultString(self.0.output);
            goffi::FreeResultString(self.0.error);
        }
    }
}

/// Go Template Renderer
pub struct TemplateRenderer<'a, T: Serialize> {
    template_content: &'a str,
    data: &'a T,
    escape_html: bool,
    use_missing_key_zero: bool,
    _marker: PhantomData<&'a T>,
}

impl<'a, T: Serialize> TemplateRenderer<'a, T> {
    /// Creates a new template renderer.
    ///
    /// # Arguments
    /// * `template_content` - Go template content as a string slice.
    /// * `data` - Data to be injected into the template, must implement `Serialize`.
    pub fn new(template_content: &'a str, data: &'a T) -> Self {
        Self {
            template_content,
            data,
            escape_html: false,
            use_missing_key_zero: false,
            _marker: PhantomData,
        }
    }

    /// Sets whether to escape HTML in the output.
    ///
    /// Defaults to `false`.
    pub fn escape_html(mut self, escape: bool) -> Self {
        self.escape_html = escape;
        self
    }

    /// Sets whether to treat missing keys as zero values.
    ///
    /// Go Template's `missingkey=zero` option.
    pub fn use_missing_key_zero(mut self, use_zero: bool) -> Self {
        self.use_missing_key_zero = use_zero;
        self
    }

    /// Executes the template rendering.
    ///
    /// # Returns
    /// Ok(String) if rendering was successful, Err(RenderError) otherwise.
    pub fn render(self) -> Result<String, RenderError> {
        //Prepare inputs
        let c_template = CString::new(self.template_content)?;

        let json_data_string = serde_json::to_string(self.data)?;
        let c_json_data = CString::new(json_data_string)?;

        #[cfg(any(target_arch = "x86_64", target_arch = "x86"))]
        // Call Go function
        let result = unsafe {
            OwnedGoResult(goffi::RenderTemplate(
                c_template.as_ptr() as *mut i8,
                c_json_data.as_ptr() as *mut i8,
                self.escape_html,
                self.use_missing_key_zero,
            ))
        };
        #[cfg(any(target_arch = "aarch64", target_arch = "arm"))]
        let result = unsafe {
            OwnedGoResult(goffi::RenderTemplate(
                c_template.as_ptr() as *mut u8,
                c_json_data.as_ptr() as *mut u8,
                self.escape_html,
                self.use_missing_key_zero,
            ))
        };

        // Process result
        let output = unsafe { CStr::from_ptr(result.0.output).to_string_lossy() };
        let error = unsafe { CStr::from_ptr(result.0.error).to_string_lossy() };

        if !error.is_empty() {
            Err(RenderError::GoExecution(error.into_owned()))
        } else {
            Ok(output.into_owned())
        }
    }
}
